import csv
from datetime import datetime

# Fonction pour enregistrer les donn√©es dans le fichier CSV
def save_to_csv(data):
    # D√©finir le chemin du fichier CSV
    file_path = "index.csv"

    # V√©rifier si le fichier existe
    file_exists = os.path.isfile(file_path)

    # Si le fichier n'existe pas, on l'ouvre en mode 'w' pour cr√©er l'en-t√™te
    with open(file_path, mode='a', newline='') as file:
        writer = csv.writer(file)

        # Si le fichier n'existe pas, on √©crit les en-t√™tes
        if not file_exists:
            writer.writerow(["N¬∞", "Date", "Nom d'utilisateur Telegram", "T√©l√©phone affich√© sur Telegram", 
                             "Num√©ro du contact", "Nom dans '√Ä qui j'ai l'honneur'", "Produit choisi", "Proposition de prix"])

        # R√©cup√©rer les informations √† sauvegarder dans le CSV
        writer.writerow(data)

# Fonction pour g√©rer le texte des messages et collecter les donn√©es
async def handle_text_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # R√©cup√©rer les informations de base
    lang = context.user_data.get("lang", "fr")
    name = update.message.text.strip()
    context.user_data["name"] = name
    username = update.message.from_user.username  # Nom d'utilisateur Telegram
    phone_number = update.message.contact.phone_number if update.message.contact else "Non fourni"

    thank_you = thank_you_texts.get(lang, thank_you_texts["fr"])
    await update.message.reply_text(f"{thank_you} {name} ! ")

    # Ajouter les donn√©es au CSV apr√®s la collecte du nom et du t√©l√©phone
    data = [
        len(open("indrx.csv", "r").readlines()) + 1,  # Num√©ro de ligne
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # Date
        username,  # Nom d'utilisateur Telegram
        phone_number,  # Num√©ro affich√© sur Telegram
        "Non pr√©cis√©",  # Num√©ro du contact √† demander plus tard
        name,  # Nom de l'utilisateur
        "Non pr√©cis√©",  # Produit choisi (sera ajout√© plus tard)
        "Non pr√©cis√©"  # Proposition de prix (sera ajout√© plus tard)
    ]

    save_to_csv(data)

    # Afficher le menu des produits apr√®s avoir collect√© ces donn√©es
    keyboard = [
        [InlineKeyboardButton(produits_text["villa"][lang], callback_data="villa")],
        [InlineKeyboardButton(produits_text["garage"][lang], callback_data="garage")],
        [InlineKeyboardButton(produits_text["terrain1"][lang], callback_data="terrain1")],
        [InlineKeyboardButton(produits_text["terrain2"][lang], callback_data="terrain2")],
        [InlineKeyboardButton(produits_text["terrain3"][lang], callback_data="terrain3")],
        [InlineKeyboardButton("üîô Revenir au Menu Langues", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Veuillez choisir un Bien :", reply_markup=reply_markup)

# Fonction pour g√©rer le choix du produit
async def handle_product_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    product = query.data
    lang = context.user_data.get("lang", "fr")
    
    # Enregistrer le produit choisi dans les donn√©es utilisateur
    context.user_data["product"] = product

    # Mettre √† jour le fichier CSV avec le produit choisi
    username = update.message.from_user.username  # Nom d'utilisateur Telegram
    with open("index.csv", "r") as file:
        rows = list(csv.reader(file))
        for row in rows:
            if row[2] == username:  # Trouver l'utilisateur dans le fichier CSV
                row[6] = product  # Mettre √† jour le produit choisi

    # Enregistrer √† nouveau dans le fichier CSV
    save_to_csv(rows)

    # Affichage des d√©tails du produit
    await query.edit_message_text(f"Produit {product} s√©lectionn√©. Voulez-vous proposer un prix ?")
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ Proposer un prix", callback_data="propose_price")],
        [InlineKeyboardButton("üîô Revenir au Menu des Biens", callback_data="menu")]
    ])
    await query.edit_message_reply_markup(reply_markup=keyboard)

# Fonction pour g√©rer la proposition de prix
async def handle_propose_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    lang = context.user_data.get("lang", "fr")
    context.user_data["awaiting_price_proposal"] = True
    prompt = ask_price_messages["propose_price_prompt"].get(lang, ask_price_messages["propose_price_prompt"]["fr"])
    await query.edit_message_text(prompt)

# Fonction pour enregistrer le prix propos√© dans le CSV
async def handle_text_messages_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("awaiting_price_proposal"):
        try:
            price = float(update.message.text)
            context.user_data["awaiting_price_proposal"] = False
            username = update.message.from_user.username  # Nom d'utilisateur Telegram

            # Mise √† jour du prix dans le CSV
            with open("index.csv", "r") as file:
                rows = list(csv.reader(file))
                for row in rows:
                    if row[2] == username:  # Trouver l'utilisateur dans le fichier CSV
                        row[7] = price  # Mettre √† jour la proposition de prix

            # Enregistrer √† nouveau dans le fichier CSV
            save_to_csv(rows)

            await update.message.reply_text(f"Merci pour votre proposition de {price:.2f} DH.")
        except ValueError:
            await update.message.reply_text("‚ùó Veuillez entrer un montant valide.")
        return
